{"version":3,"file":"actionstack-store.mjs","sources":["../../../../libraries/actionstack/store/src/lib/types.ts","../../../../libraries/actionstack/store/src/lib/actions.ts","../../../../libraries/actionstack/store/src/lib/hash.ts","../../../../libraries/actionstack/store/src/lib/lock.ts","../../../../libraries/actionstack/store/src/lib/selectors.ts","../../../../libraries/actionstack/store/src/lib/stack.ts","../../../../libraries/actionstack/store/src/lib/starter.ts","../../../../libraries/actionstack/store/src/lib/utils.ts","../../../../libraries/actionstack/store/src/lib/tracker.ts","../../../../libraries/actionstack/store/src/lib/store.ts","../../../../libraries/actionstack/store/src/public-api.ts","../../../../libraries/actionstack/store/src/actionstack-store.ts"],"sourcesContent":["import { Observable } from 'rxjs/internal/Observable';\r\nimport { ExecutionStack, SimpleLock, Store, StoreSettings } from '../lib';\r\n\r\n/**\r\n * Interface defining the structure of an action object.\r\n *\r\n * Actions are the primary way to communicate state changes in Actionstack-like stores.\r\n * This interface defines the expected properties for an action.\r\n *\r\n * @typeparam T - Optional type parameter for the action payload. Defaults to `any`.\r\n */\r\nexport interface Action<T = any> {\r\n  type: string;\r\n  payload?: T;\r\n  error?: boolean;\r\n  meta?: any;\r\n  source?: any;\r\n}\r\n\r\n/**\r\n * Interface defining the structure of an asynchronous action.\r\n *\r\n * Asynchronous actions are functions that return promises, allowing for\r\n * handling asynchronous operations like network requests or timers within actions.\r\n *\r\n * @typeparam T - Optional type parameter for the action payload type (resolved promise value). Defaults to `any`.\r\n */\r\nexport interface AsyncAction<T = any> {\r\n  (...args: any[]): Promise<T>;\r\n}\r\n\r\n/**\r\n * Represents an action creator.\r\n * @template T The type of the action payload.\r\n */\r\nexport type ActionCreator<T = any> = ((...args: any[]) => Action<T> | AsyncAction<T>) & {\r\n  toString(): string;\r\n  type: string;\r\n  match(action: Action<T>): boolean;\r\n}\r\n\r\n/**\r\n * A function that takes the current state and an action, and returns\r\n * the updated state (excluding promises).\r\n */\r\nexport type Reducer = (state: any, action: Action) => Exclude<any, Promise<any>>;\r\n\r\n/**\r\n * Type alias for an asynchronous reducer function.\r\n *\r\n * An asynchronous reducer is a function that takes the current state and an action object as arguments.\r\n * It returns a promise that resolves to the updated state after potentially performing asynchronous operations.\r\n *\r\n * @param state - The current state of the application.\r\n * @param action - The action object being dispatched.\r\n * @returns Promise<any> - A promise that resolves to the updated state after asynchronous operations (if any).\r\n */\r\nexport type AsyncReducer<T = any> = (state: T, action: Action) => Promise<T>;\r\n\r\n/**\r\n * Type alias for a meta-reducer function.\r\n *\r\n * A meta-reducer is a higher-order function that takes an asynchronous reducer as an argument.\r\n * It returns a promise that resolves to a potentially modified asynchronous reducer.\r\n * Meta-reducers are used to apply additional logic or middleware functionality around reducers.\r\n *\r\n * @param reducer - The asynchronous reducer function to be wrapped or modified.\r\n * @returns Promise<AsyncReducer> - A promise that resolves to a potentially modified asynchronous reducer.\r\n */\r\nexport type MetaReducer = (reducer: AsyncReducer) => Promise<AsyncReducer>;\r\n\r\n/**\r\n * Defines the methods and properties available to middleware for interacting with the store.\r\n * Provides access to state, dispatching actions, dependencies, processing strategy,\r\n * synchronization, and execution stack.\r\n *\r\n * @property {function([string[]]): any} getState - Retrieves the state or a specific slice of the state.\r\n * @property {function(Action|AsyncAction): Promise<void>} dispatch - Dispatches an action (synchronous or asynchronous).\r\n * @property {function(): any} dependencies - Retrieves the current dependencies in the pipeline.\r\n * @property {function(): ProcessingStrategy} strategy - Retrieves the current processing strategy.\r\n * @property {SimpleLock} lock - A lock to synchronize or prevent concurrent access to resources.\r\n * @property {ExecutionStack} stack - The execution stack tracking the sequence of actions or operations.\r\n */\r\nexport type MiddlewareAPI = {\r\n  getState: (slice?: string[]) => any;\r\n  dispatch: (action: Action | AsyncAction) => Promise<void>;\r\n  dependencies: () => any;\r\n  strategy: () => ProcessingStrategy;\r\n  lock: SimpleLock;\r\n  stack: ExecutionStack;\r\n}\r\n\r\n/**\r\n * Interface defining the structure of a middleware function.\r\n *\r\n * Middleware functions are used to intercept, handle, and potentially modify the dispatching process in Actionstack-like stores.\r\n * This interface defines the expected behavior for a middleware function.\r\n *\r\n * @property (api: Store) => (next: Function) => (action: any) => Promise<any> | any\r\n *  - A function that takes the store instance as an argument.\r\n *  - It returns another function that takes the `next` function in the middleware chain as an argument.\r\n *  - The inner function can perform logic before and/or after calling the `next` function with the action.\r\n *  - It can optionally return a promise that resolves to a modified version of the `next` function,\r\n *      allowing for asynchronous middleware behavior.\r\n *  - Alternatively, it can return any value to potentially short-circuit the middleware chain.\r\n *\r\n * @property signature?: string (optional)\r\n *  - An optional string property that can be used to define a signature for the middleware,\r\n *      aiding in type checking and documentation.\r\n */\r\nexport interface Middleware {\r\n  (api: any): (next: Function) => (action: Action) => Promise<any> | any;\r\n  signature?: string;\r\n}\r\n\r\n/**\r\n * Represents an observer that receives notifications of values from an Observable.\r\n * @interface\r\n * @template T The type of the value being observed.\r\n */\r\nexport interface Observer<T> {\r\n  next: (value: T) => void;\r\n  error: (err: any) => void;\r\n  complete: () => void;\r\n}\r\n\r\n/**\r\n * Represents an asynchronous observer that receives notifications of values from an Observable.\r\n * @interface\r\n * @template T The type of the value being observed.\r\n */\r\nexport interface AsyncObserver<T> {\r\n  next: (value: T) => Promise<void>;\r\n  error: (err: any) => Promise<void>;\r\n  complete: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Interface representing an operator function for transforming observables.\r\n *\r\n * An operator function takes an input `Observable<T>` and returns an output `Observable<R>`.\r\n *\r\n * @typeParam T - The type of the input elements.\r\n * @typeParam R - The type of the output elements.\r\n */\r\nexport interface OperatorFunction<T, R> {\r\n  (source: Observable<T>): Observable<R>\r\n}\r\n\r\n/**\r\n * Type alias for any function that takes any number of arguments and returns anything.\r\n *\r\n * This type is used to represent a generic function without specifying a specific argument or return type.\r\n * It can be helpful for situations where the exact function signature is not important.\r\n */\r\nexport type AnyFn = (...args: any[]) => any;\r\n\r\n/**\r\n * Interface defining the structure of a selector function.\r\n *\r\n * Selectors are functions that extract specific data or derived values from the Actionstack store's state.\r\n * This interface defines the expected behavior for a selector function.\r\n *\r\n * @param state - The current state of the application.\r\n * @param props?: any (optional) - Optional props object that can be used by the selector for additional logic.\r\n * @returns any - The selected value or derived data from the state.\r\n */\r\nexport interface SelectorFunction {\r\n  (state: any, props?: any): any;\r\n}\r\n\r\n/**\r\n * Interface defining the structure of a projection function.\r\n *\r\n * Projection functions are similar to selector functions, but they can handle projecting data from\r\n * either a single state object or an array of state objects.\r\n * This interface defines the expected behavior for a projection function.\r\n *\r\n * @param state - The current state of the application (can be a single object or an array of state objects).\r\n * @param props?: any (optional) - Optional props object that can be used by the projection function for additional logic.\r\n * @returns any - The projected value or derived data from the state.\r\n */\r\nexport interface ProjectionFunction {\r\n  (state: any | any[], props?: any): any;\r\n}\r\n\r\n/**\r\n * Type alias representing a recursive tree structure.\r\n *\r\n * This type is used to define nested objects in a hierarchical way.\r\n * - `LeafType`: The type for the leaf nodes of the tree (representing the base values).\r\n * - `T`: Optional type parameter for the root object type (defaults to `any`).\r\n *\r\n * The structure works as follows:\r\n *  - For each property key `K` in the root object type `T`:\r\n *      - If the property value `T[K]` is an object:\r\n *          - The type for that property becomes another `Tree` instance, recursively defining the nested structure.\r\n *      - If the property value `T[K]` is not an object:\r\n *          - The type for that property becomes the `LeafType`.\r\n *\r\n * This type allows for representing complex object structures with nested objects and leaf nodes.\r\n */\r\nexport type Tree<LeafType, T = any> = {\r\n  [K in keyof T]: T[K] extends object ? Tree<LeafType, T[K]> : LeafType;\r\n};\r\n\r\n/**\r\n * Type alias representing processing strategies for side effects.\r\n *\r\n */\r\nexport type ProcessingStrategy = \"exclusive\" | \"concurrent\";\r\n\r\n/**\r\n * Type alias representing slice strategies.\r\n *\r\n */\r\nexport type SliceStrategy = \"persistent\" | \"temporary\";\r\n\r\n/**\r\n * Interface defining the structure of a feature module.\r\n *\r\n * Feature modules are used to organize state and logic for specific parts of an application.\r\n * This interface defines the expected properties for a feature module.\r\n *\r\n * @property slice - A unique string identifier for the feature module's state slice in the store.\r\n * @property reducer - The reducer function or a tree of reducers responsible for managing the state of the feature.\r\n *                  - A reducer function takes the current state slice and an action object,\r\n *                    and returns the updated state slice based on the action.\r\n *                  - A tree of reducers allows for defining nested reducers for complex state structures.\r\n * @property dependencies?: Tree<any> (optional) -\r\n *                   An optional tree representing the dependencies required by the feature module.\r\n *                   - These dependencies can be types (like classes or interfaces) or injection tokens\r\n *                     used for dependency injection.\r\n *                   - The tree structure allows for specifying nested dependencies within the feature.\r\n */\r\nexport type FeatureModule = {\r\n  slice: string;\r\n  reducer: Reducer | AsyncReducer | Tree<Reducer | AsyncReducer>;\r\n  dependencies?: Tree<any>;\r\n}\r\n\r\n/**\r\n * Interface defining the structure of the main application module.\r\n *\r\n * The main application module serves as the entry point for configuring the Actionstack store.\r\n * This interface defines the expected properties for the main application module.\r\n *\r\n * @property metaReducers?: MetaReducer[] (optional) - An array of meta-reducer functions to be applied to the reducers.\r\n *                  - Meta-reducers are higher-order functions that can wrap and potentially modify reducers,\r\n *                    adding additional logic or middleware functionality.\r\n */\r\nexport type MainModule =  Omit<FeatureModule, \"slice\"> & {\r\n  slice?: \"main\";\r\n  metaReducers?: MetaReducer[];\r\n}\r\n\r\n/**\r\n * Default configuration for the main module.\r\n * Includes a slice name, a basic reducer, an empty list of metaReducers, and no dependencies.\r\n */\r\nexport const defaultMainModule = {\r\n  slice: \"main\" as \"main\",\r\n  reducer: (state: any = {}) => state as Reducer,\r\n  metaReducers: [],\r\n  dependencies: {}\r\n};\r\n\r\n/**\r\n * Type definition for a function that creates a store instance.\r\n *\r\n * @template T - The type of the state managed by the store.\r\n * @param {MainModule} module - The main module configuration, defining the initial state, reducers, middleware, and other store properties.\r\n * @param {StoreSettings} [settings] - Optional settings for the store, such as dispatch behavior or feature toggles.\r\n * @param {StoreEnhancer} [enhancer] - Optional enhancer function to extend or modify the store's functionality.\r\n * @returns {Store<T>} The created store instance with methods for managing state and actions.\r\n */\r\nexport type StoreCreator<T = any> = (module: MainModule, settings?: StoreSettings, enhancer?: StoreEnhancer) => Store<T>;\r\n\r\n/**\r\n * Type alias for a store enhancer function.\r\n *\r\n * This type represents a function that takes the next store creation function as an argument,\r\n * and returns a new store creation function potentially with additional functionality.\r\n * Store enhancers are used to extend the capabilities of the store creation process.\r\n *\r\n * @param next - The next store creation function in the chain (typically the default store creator).\r\n * @returns StoreCreator - A new store creation function that potentially wraps the original one\r\n *                         and provides additional functionality.\r\n */\r\nexport type StoreEnhancer = (next: StoreCreator) => StoreCreator;\r\n\r\n/**\r\n * Determines the type of a given value.\r\n *\r\n * This function attempts to identify the underlying type of a JavaScript value\r\n * using a combination of checks and built-in functions.\r\n *\r\n * @param val - The value to determine the type for.\r\n * @returns string - A string representing the type of the value (e.g., \"undefined\", \"string\", \"array\", etc.).\r\n */\r\nfunction kindOf(val: any): string {\r\n  if (val === undefined)\r\n    return \"undefined\";\r\n  if (val === null)\r\n    return \"null\";\r\n\r\n  const type = typeof val;\r\n  switch (type) {\r\n    case \"boolean\":\r\n    case \"string\":\r\n    case \"number\":\r\n    case \"symbol\":\r\n    case \"function\": {\r\n      return type;\r\n    }\r\n  }\r\n\r\n  if (Array.isArray(val))\r\n    return \"array\";\r\n\r\n  if (isDate(val))\r\n    return \"date\";\r\n\r\n  if (isError(val))\r\n    return \"error\";\r\n\r\n  if (isObservable(val))\r\n    return \"observable\";\r\n\r\n  if (isPromise(val))\r\n    return \"promise\";\r\n\r\n  const constructorName = ctorName(val);\r\n  switch (constructorName) {\r\n    case \"Symbol\":\r\n    case \"WeakMap\":\r\n    case \"WeakSet\":\r\n    case \"Map\":\r\n    case \"Set\":\r\n      return constructorName;\r\n  }\r\n\r\n  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\r\n}\r\n\r\n/**\r\n * Attempts to get the constructor name of a value.\r\n *\r\n * This function checks if the value has a constructor that is a function,\r\n * and if so, it returns the name of the constructor. Otherwise, it returns null.\r\n *\r\n * @param val - The value to get the constructor name for.\r\n * @returns string - The name of the constructor (if applicable), otherwise null.\r\n */\r\nfunction ctorName(val: any): string | null {\r\n  return typeof val.constructor === \"function\" ? val.constructor.name : null;\r\n}\r\n\r\n/**\r\n * Checks if a value is an Error object.\r\n *\r\n * This function uses two criteria to determine if a value is an Error:\r\n *   - It checks if the value is an instance of the built-in `Error` class.\r\n *   - It checks if the value has a string property named \"message\" and a constructor with a number property named \"stackTraceLimit\".\r\n *\r\n * @param val - The value to check if it's an Error.\r\n * @returns boolean - True if the value is an Error, false otherwise.\r\n */\r\nfunction isError(val: any): boolean {\r\n  return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\r\n}\r\n\r\n/**\r\n * Checks if a value is a Date object.\r\n *\r\n * This function uses two approaches to determine if a value is a Date:\r\n *   - It checks if the value is an instance of the built-in `Date` class.\r\n *   - It checks if the value has functions named `toDateString`, `getDate`, and `setDate`.\r\n *\r\n * @param val - The value to check if it's a Date.\r\n * @returns boolean - True if the value is a Date, false otherwise.\r\n */\r\nfunction isDate(val: any): boolean {\r\n  if (val instanceof Date)\r\n    return true;\r\n\r\n  return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\r\n}\r\n\r\n/**\r\n * Checks if a value is a boxed primitive.\r\n *\r\n * This function checks if a value is not `undefined` or `null`, and its value doesn't strictly equal itself when called with `valueOf()`.\r\n * Primitive values wrapped in their corresponding object representations (e.g., new Number(10)) are considered boxed.\r\n *\r\n * @param value - The value to check if it's boxed.\r\n * @returns boolean - True if the value is a boxed primitive, false otherwise.\r\n */\r\nfunction isBoxed(value: any) {\r\n  return value !== undefined && value !== null && value.valueOf() !== value;\r\n}\r\n\r\n/**\r\n * Checks if a value is a Promise object.\r\n *\r\n * This function uses a trick to identify promises. It resolves the value with `Promise.resolve` and compares the resolved value with the original value.\r\n * If they are the same, it's likely a promise.\r\n *\r\n * @param value - The value to check if it's a Promise.\r\n * @returns boolean - True if the value is a Promise, false otherwise.\r\n */\r\nfunction isPromise(value: any) {\r\n  return Promise.resolve(value) == value;\r\n}\r\n\r\n/**\r\n * Checks if a value is a valid Actionstack action object.\r\n *\r\n * This function determines if the provided value is a valid action object\r\n * used in Actionstack for dispatching state changes.\r\n *\r\n * @param action - The value to check if it's a Actionstack action.\r\n * @returns boolean - True if the value is a plain object with a string property named \"type\", false otherwise.\r\n */\r\nfunction isAction(action: any): boolean {\r\n  return isPlainObject(action) && \"type\" in action && typeof action.type === \"string\";\r\n}\r\n\r\n/**\r\n * Checks if a function is an async function.\r\n *\r\n * This function uses the constructor name to determine if the provided function\r\n * is an async function introduced in ES2018.\r\n *\r\n * @param func - The function to check if it's an async function.\r\n * @returns boolean - True if the function's constructor name is \"AsyncFunction\", false otherwise.\r\n */\r\nfunction isAsync(func: Function) {\r\n  return func.constructor.name === \"AsyncFunction\";\r\n}\r\n\r\n/**\r\n * Checks if a value is a plain object.\r\n *\r\n * This function determines if the provided value is a plain object (an object\r\n * that doesn't inherit from other prototypes).\r\n *\r\n * @param obj - The value to check if it's a plain object.\r\n * @returns boolean - True if the value is an object and its prototype is the same as the Object.prototype, false otherwise.\r\n */\r\nfunction isPlainObject(obj: any): boolean {\r\n  if (typeof obj !== \"object\" || obj === null)\r\n    return false;\r\n\r\n  let proto = obj;\r\n  while (Object.getPrototypeOf(proto) !== null) {\r\n    proto = Object.getPrototypeOf(proto);\r\n  }\r\n\r\n  return Object.getPrototypeOf(obj) === proto;\r\n}\r\n\r\n/**\r\n * Tests to see if the object is an RxJS {@link Observable}\r\n * @param obj the object to test\r\n */\r\nfunction isObservable(obj: any): obj is Observable<unknown> {\r\n  // The !! is to ensure that this publicly exposed function returns\r\n  // `false` if something like `null` or `0` is passed.\r\n  return !!obj && (obj instanceof Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));\r\n}\r\n\r\n/**\r\n * Observable that immediately completes without emitting any values\r\n */\r\nexport const EMPTY = new Observable<never>((subscriber) => {\r\n  subscriber.complete();\r\n});\r\n\r\nexport { isAction, isAsync, isBoxed, isObservable, isPlainObject, isPromise, kindOf };\r\n\r\n","import { Action, ActionCreator, isAction, kindOf } from './types';\r\n\r\nexport { createAction as action };\r\n\r\n/**\r\n * Creates an action creator function for Actionstack actions, supporting both synchronous and asynchronous use cases.\r\n *\r\n * @param {string|Function} typeOrThunk   - A string representing the action type for synchronous actions,\r\n *                                          or a function representing a thunk for asynchronous actions.\r\n * @param {Function} [payloadCreator]     - (Optional) A function to generate the payload for the action.\r\n * @returns {Function}                    - An action creator function that generates action objects or dispatchable thunks.\r\n *\r\n * This function allows the creation of action creators for both synchronous and asynchronous workflows:\r\n *\r\n * - **Synchronous Actions**: When `typeOrThunk` is a string, the returned action creator generates objects\r\n *   with a `type` property and optionally a `payload`, `meta`, and `error` property.\r\n *   - If a `payloadCreator` is provided, it is used to generate the payload.\r\n *   - If no `payloadCreator` is provided, the first argument passed to the action creator is used as the payload.\r\n *\r\n * - **Asynchronous Actions (Thunks)**: When `typeOrThunk` is a function, the returned action creator creates\r\n *   a dispatchable thunk. The thunk receives `dispatch`, `getState`, and optional `dependencies` as arguments,\r\n *   allowing for asynchronous logic.\r\n *   - Errors in the thunk are caught and logged with a warning.\r\n *\r\n * **Example Usage:**\r\n *\r\n * Synchronous:\r\n * ```typescript\r\n * const increment = createAction('INCREMENT', (amount) => ({ amount }));\r\n * dispatch(increment(1));\r\n * // Output: { type: 'INCREMENT', payload: { amount: 1 } }\r\n * ```\r\n *\r\n * Asynchronous:\r\n * ```typescript\r\n * const fetchData = createAction(async (dispatch, getState) => {\r\n *   const data = await fetch('/api/data');\r\n *   dispatch({ type: 'DATA_FETCHED', payload: await data.json() });\r\n * });\r\n * dispatch(fetchData);\r\n * ```\r\n *\r\n * Warnings:\r\n * - If `payloadCreator` returns `undefined` or `null`, a warning is issued.\r\n * - For thunks, an error in execution logs a warning.\r\n */\r\nexport function createAction(typeOrThunk: string | Function, payloadCreator?: Function): ActionCreator {\r\n  function actionCreator(...args: any[]) {\r\n    let action: Action = {\r\n      type: typeOrThunk as string,\r\n    };\r\n\r\n    if (typeof typeOrThunk === 'function') {\r\n      return async (dispatch: Function, getState: Function, dependencies: any) => {\r\n        try {\r\n          return await typeOrThunk(...args)(dispatch, getState, dependencies);\r\n        } catch (error: any) {\r\n          console.warn(`Error in action: ${error.message}. If dependencies object provided does not contain required property, it is possible that the slice name obtained from the tag name does not match the one declared in the slice file.`);\r\n        }\r\n      }\r\n    } else if (payloadCreator) {\r\n      let result = payloadCreator(...args);\r\n      if (result === undefined || result === null) {\r\n        console.warn('payloadCreator did not return an object. Did you forget to initialize an action with params?');\r\n      }\r\n\r\n      // Do not return payload if it is undefined\r\n      if (result !== undefined && result !== null) {\r\n        action.payload = result;\r\n        'meta' in result && (action.meta = result.meta);\r\n        'error' in result && (action.error = result.error);\r\n      }\r\n    }\r\n    else {\r\n      // Do not return payload if it is undefined\r\n      if (args[0] !== undefined) {\r\n        action.payload = args[0];\r\n      }\r\n    }\r\n\r\n    return action;\r\n  }\r\n\r\n  actionCreator.toString = () => `${typeOrThunk}`;\r\n  actionCreator.type = typeof typeOrThunk === 'string' ? typeOrThunk : 'asyncAction';\r\n  actionCreator.match = (action: any) => isAction(action) && action.type === typeOrThunk;\r\n\r\n  return actionCreator;\r\n}\r\n\r\n/**\r\n * Binds an action creator to the dispatch function.\r\n *\r\n * @param {Function} actionCreator   - The action creator function to be bound.\r\n * @param {Function} dispatch        - The dispatch function.\r\n * @returns {Function}               - A new function that dispatches the action created by the provided action creator.\r\n *\r\n * This function takes an action creator function and the dispatch function.\r\n * It returns a new function that, when called, will dispatch the action created by the provided action creator.\r\n * The new function can be called with any arguments, which will be passed on to the original action creator function.\r\n */\r\nexport function bindActionCreator(actionCreator: Function, dispatch: Function): Function {\r\n  return function(this: any, ...args: any[]): any {\r\n    return dispatch(actionCreator.apply(this, args));\r\n  };\r\n}\r\n\r\n/**\r\n * Binds one or more action creators to a dispatch function, making it easier to call actions directly.\r\n *\r\n * @param {Object|Function} actionCreators - An object containing multiple action creator functions\r\n *                                           or a single action creator function.\r\n * @param {Function} dispatch              - The dispatch function to bind the action creators to.\r\n * @returns {Object|Function}              - An object with the bound action creator functions\r\n *                                           or a single bound action creator function.\r\n *\r\n * This function accepts either:\r\n * - An object containing multiple action creator functions:\r\n *   Each function in the object will be wrapped by `bindActionCreator` to automatically dispatch\r\n *   actions when called, and the resulting object will be returned.\r\n * - A single action creator function:\r\n *   The function will be wrapped and returned as a bound action creator.\r\n *\r\n * It also performs type-checking to ensure the provided `actionCreators` parameter is either\r\n * an object or a function, issuing a warning if the input type is incorrect.\r\n *\r\n * This utility simplifies the process of binding all action creators from a module or file\r\n * to the dispatch function, resulting in cleaner and more concise component code.\r\n */\r\nexport function bindActionCreators(actionCreators: Record<string, Function> | Function, dispatch: Function): any {\r\n  if (typeof actionCreators !== \"object\" || actionCreators === null) {\r\n    console.warn(`bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`);\r\n    return undefined;\r\n  }\r\n\r\n  actionCreators = { ...actionCreators };\r\n  if (typeof actionCreators === \"function\") {\r\n    return bindActionCreator(actionCreators, dispatch);\r\n  }\r\n\r\n  const keys = Object.keys(actionCreators);\r\n  const numKeys = keys.length;\r\n\r\n  if (numKeys === 1) {\r\n    const actionCreator = actionCreators[keys[0]];\r\n\r\n    if (typeof actionCreator === \"function\") {\r\n      return bindActionCreator(actionCreator, dispatch);\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < numKeys; i++) {\r\n    const key = keys[i];\r\n    const actionCreator = actionCreators[key];\r\n\r\n    if (typeof actionCreator === \"function\") {\r\n      actionCreators[key] = bindActionCreator(actionCreator, dispatch);\r\n    }\r\n  }\r\n\r\n  return actionCreators;\r\n}\r\n","/**\r\n * Generates a random string of a specified length in base-36 (including digits and lowercase letters).\r\n *\r\n * @param {number} length  - The desired length of the random string.\r\n * @returns {string}       - A random base-36 string of the provided length.\r\n */\r\nexport function salt(length: number) {\r\n  return Math.random().toString(36).substring(2).padStart(length, \"0\").slice(0, length);\r\n}\r\n\r\n/**\r\n * Creates a simple 3-character hash of a string using a basic multiplication-based algorithm.\r\n *\r\n * @param {string} str - The string to be hashed.\r\n * @returns {string}   - A 3-character base-36 string representing the hash of the input string.\r\n */\r\nexport function hash(str: string) {\r\n  let h = 0;\r\n  for (let i = 0; i < str.length; i++) {\r\n    h = 31 * h + str.charCodeAt(i);\r\n  }\r\n  // Convert to base-36 string and pad with zeros\r\n  let hash = h.toString(36).padStart(3, \"0\");\r\n  // Return the first 3 characters of the hash\r\n  return hash.slice(0, 3);\r\n}\r\n\r\n/**\r\n * Generates a signature by combining a random salt and a 3-character hash of the salt, separated by dots.\r\n *\r\n * @returns {string} - A string containing the salt and its hash separated by dots (e.g., \"abc.def\").\r\n */\r\nexport function signature() {\r\n  let payload = salt(7), hashstr = hash(payload);\r\n  return payload.concat(hashstr).split('').join('.');\r\n}\r\n\r\n/**\r\n * Validates a provided signature string based on its format and internal hash check.\r\n *\r\n * @param {string} sign  - The signature string to be validated.\r\n * @returns {boolean}    - True if the signature is a valid format and the internal hash check passes, false otherwise.\r\n */\r\nexport function isValidSignature(sign: string) {\r\n  return typeof sign === 'string' && (sign = sign.replace(/\\./g, '')).length === 10 && hash(sign.slice(0, 7)) === sign.slice(7, 10);\r\n}\r\n","/**\r\n * A simple lock to control access to a shared resource.\r\n * Ensures only one operation can acquire the lock at a time.\r\n */\r\nexport type SimpleLock = {\r\n  acquire: () => Promise<void>;\r\n  release: () => void;\r\n};\r\n\r\n/**\r\n * Creates a new instance of a simple lock.\r\n * Allows acquiring and releasing the lock, with queued resolvers when the lock is held.\r\n *\r\n * @returns {SimpleLock} - The lock object with acquire and release methods.\r\n */\r\nexport const createLock = (): SimpleLock => {\r\n  let isLocked = false; // Tracks whether the lock is held\r\n  const queue: Array<() => void> = []; // Queue to store waiting promise resolvers\r\n\r\n  const acquire = () =>\r\n    new Promise<void>((resolve) => {\r\n      if (!isLocked) {\r\n        isLocked = true;\r\n        resolve(); // Immediately resolve if the lock is free\r\n      } else {\r\n        queue.push(resolve); // Otherwise, queue the resolve function\r\n      }\r\n    });\r\n\r\n  const release = () => {\r\n    if (!isLocked) {\r\n      throw new Error(\"Cannot release a lock that is not acquired.\");\r\n    }\r\n\r\n    const nextResolve = queue.shift();\r\n    if (nextResolve) {\r\n      nextResolve(); // Allow the next waiting function to acquire the lock\r\n      // Keep `isLocked` as true because the lock is still held by the next resolver\r\n    } else {\r\n      isLocked = false; // No more waiting, so release the lock\r\n    }\r\n  };\r\n\r\n  return { acquire, release };\r\n};\r\n","import { ProjectionFunction, SelectorFunction } from './types';\r\n\r\nexport {\r\n  createFeatureSelector as featureSelector,\r\n  createSelector as selector,\r\n  createSelectorAsync as selectorAsync\r\n};\r\n\r\n/**\r\n * Recursively resolves the type of a deeply nested property based on a path array.\r\n *\r\n * @template T - The root object type (e.g., full state).\r\n * @template P - A string array representing the path to the nested value.\r\n */\r\nexport type ValueAtPath<T, P extends readonly any[]> =\r\n  P extends [infer K, ...infer Rest]\r\n    ? K extends keyof T\r\n      ? Rest extends []\r\n        ? T[K]\r\n        : ValueAtPath<T[K], Rest>\r\n      : unknown\r\n    : unknown;\r\n\r\n/**\r\n * Selects a nested property from a plain object state using a path of keys.\r\n *\r\n * @template T The root state object type.\r\n * @template P A key of the object or a path array.\r\n *\r\n * @param slice The key or path to the desired nested value.\r\n *\r\n * @returns A selector function that takes a plain object state and returns the nested value.\r\n */\r\nexport function createFeatureSelector<\r\n  T = any,\r\n  P extends keyof T | readonly string[] = keyof T\r\n>(\r\n  slice: P\r\n): (state: T) =>\r\n  (P extends keyof T\r\n    ? T[P]\r\n    : P extends readonly string[]\r\n      ? ValueAtPath<T, P>\r\n      : unknown) | undefined {\r\n\r\n  return (state: T) => {\r\n    if (Array.isArray(slice)) {\r\n      return slice.reduce<any>((acc, key) => acc?.[key], state);\r\n    } else {\r\n      return state[slice as keyof T];\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Composes multiple selectors into one, applying an optional projection function.\r\n *\r\n * @template T Slice type extracted from state.\r\n * @template U Final return type after projection.\r\n *\r\n * @param featureSelector Selector for extracting the slice from full state, or \"@global\" for entire state.\r\n * @param selectors A selector or array of selectors for extracting intermediate values.\r\n * @param projection Optional function to project intermediate values into a final result.\r\n *\r\n * @returns A selector that computes a derived value from the slice using the specified selectors.\r\n */\r\nfunction createSelector<T = any, U = any>(\r\n  featureSelector: ((state: any) => T | undefined) | \"@global\",\r\n  selectors: SelectorFunction | SelectorFunction[],\r\n  projectionOrOptions?: ProjectionFunction\r\n): (props?: any[] | any, projectionProps?: any) => (state: any) => U | undefined {\r\n\r\n  const isSelectorArray = Array.isArray(selectors);\r\n  const projection = typeof projectionOrOptions === \"function\" ? projectionOrOptions : undefined;\r\n\r\n  return (props?: any[] | any, projectionProps?: any) => {\r\n    return (state: any): U | undefined => {\r\n      const sliceState = featureSelector === \"@global\" ? state : featureSelector(state);\r\n      if (sliceState === undefined) return undefined;\r\n\r\n      try {\r\n        if (isSelectorArray) {\r\n          const results = selectors.map((selector, i) =>\r\n            selector(sliceState, props?.[i])\r\n          );\r\n          if (results.some(r => r === undefined)) return undefined;\r\n          return projection!(results, projectionProps);\r\n        } else {\r\n          const result = selectors(sliceState, props);\r\n          return result === undefined\r\n            ? undefined\r\n            : projection\r\n              ? projection(result, projectionProps)\r\n              : result;\r\n        }\r\n      } catch (error: any) {\r\n        console.warn(\"Selector execution error:\", error.message);\r\n        return undefined;\r\n      }\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Similar to `createSelector` but supports asynchronous selector functions.\r\n *\r\n * @template T Slice type extracted from state.\r\n * @template U Final return type after projection.\r\n *\r\n * @param featureSelector Selector for extracting the slice from full state, or \"@global\" for entire state.\r\n * @param selectors A selector or array of selectors returning a value, Promise, or Observable-like.\r\n * @param projection Optional function to project intermediate values into a final result.\r\n *\r\n * @returns A selector that returns a Promise of a derived value from the state.\r\n */\r\nfunction createSelectorAsync<T = any, U = any>(\r\n  featureSelector: ((state: any) => T | undefined) | \"@global\",\r\n  selectors: SelectorFunction | SelectorFunction[],\r\n  projectionOrOptions?: ProjectionFunction\r\n): (props?: any[] | any, projectionProps?: any) => (state: any) => Promise<U | undefined> {\r\n\r\n  const isSelectorArray = Array.isArray(selectors);\r\n  const projection = typeof projectionOrOptions === \"function\" ? projectionOrOptions : undefined;\r\n\r\n  return (props?: any[] | any, projectionProps?: any) => {\r\n    return async (state: any): Promise<U | undefined> => {\r\n      const sliceState = featureSelector === \"@global\" ? state : featureSelector(state);\r\n      if (sliceState === undefined) return undefined;\r\n\r\n      try {\r\n        if (isSelectorArray) {\r\n          const results = await Promise.all(\r\n            selectors.map((selector, i) => selector(sliceState, props?.[i]))\r\n          );\r\n          if (results.some(r => r === undefined)) return undefined;\r\n          return projection!(results, projectionProps);\r\n        } else {\r\n          const result = await selectors(sliceState, props);\r\n          return result === undefined\r\n            ? undefined\r\n            : projection\r\n              ? projection(result, projectionProps)\r\n              : result;\r\n        }\r\n      } catch (error: any) {\r\n        console.warn(\"Async selector error:\", error.message);\r\n        return undefined;\r\n      }\r\n    };\r\n  };\r\n}\r\n","import { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';\r\nimport { Observable } from 'rxjs/internal/Observable';\r\nimport { Action, AsyncAction } from './types';\r\n\r\n/**\r\n * Represents the type of an operation (action, asyncAction, epic, or saga).\r\n */\r\nexport type InstructionType = \"action\" | \"asyncAction\" | \"epic\" | \"saga\";\r\n\r\n/**\r\n * Represents an operation with a specified type and instance, and optionally a context.\r\n */\r\nexport interface Instruction {\r\n  type: InstructionType;\r\n  instance: any;\r\n  context?: Instruction;\r\n}\r\n\r\n/**\r\n * Factory methods for creating operations of different types.\r\n */\r\nexport const createInstruction = {\r\n  /**\r\n   * Creates an instruction for an action or async action.\r\n   * @param action The action or async action to wrap in an instruction.\r\n   * @returns The corresponding instruction.\r\n   */\r\n  action: (action: Action | AsyncAction): Instruction => {\r\n    const operationType: InstructionType = typeof action === 'function' ? \"asyncAction\" : \"action\";\r\n    const source = (action as any).source;\r\n    return { type: operationType, instance: action, context: source };\r\n  },\r\n\r\n  /**\r\n   * Creates an instruction for a saga.\r\n   * @param saga The saga function.\r\n   * @returns The corresponding instruction.\r\n   */\r\n  saga: (saga: Function): Instruction => ({ type: \"saga\", instance: saga }),\r\n\r\n  /**\r\n   * Creates an instruction for an epic.\r\n   * @param epic The epic function.\r\n   * @returns The corresponding instruction.\r\n   */\r\n  epic: (epic: Function): Instruction => ({ type: \"epic\", instance: epic }),\r\n};\r\n\r\n/**\r\n * Checks if the given object is a valid Instruction.\r\n * @param obj The object to check.\r\n * @returns True if the object is a valid Instruction, false otherwise.\r\n */\r\nexport const isInstruction = (obj: any): boolean => {\r\n  return obj?.type !== undefined && obj?.instance !== undefined;\r\n};\r\n\r\n/**\r\n * Represents a stack for managing operations with observable capabilities.\r\n */\r\nexport type ExecutionStack = {\r\n  length: number;\r\n  add: (item: Instruction) => void;\r\n  peek: () => Instruction | undefined;\r\n  remove: (item: Instruction) => Instruction | undefined;\r\n  clear: () => void;\r\n  toArray: () => Instruction[];\r\n  findLast: (condition: (element: Instruction) => boolean) => Instruction | undefined;\r\n  waitForEmpty: () => Promise<Instruction[]>;\r\n  waitForIdle: () => Promise<Instruction[]>;\r\n  observable: Observable<Instruction[]>;\r\n}\r\n\r\n/**\r\n * Creates a stack for managing operations with observable capabilities.\r\n * This stack allows you to add, remove, and query instructions (operations),\r\n * as well as observe changes to the stack.\r\n */\r\nexport const createExecutionStack = () => {\r\n  const stack$ = new BehaviorSubject<Instruction[]>([]);\r\n\r\n  return {\r\n    /**\r\n     * Gets the current length of the stack.\r\n     * @returns The length of the stack.\r\n     */\r\n    get length(): number {\r\n      return stack$.value.length;\r\n    },\r\n\r\n    /**\r\n     * Adds an operation to the stack.\r\n     * @param item The operation (instruction) to add.\r\n     */\r\n    add(item: Instruction): void {\r\n      stack$.next([...stack$.value, item]);\r\n    },\r\n\r\n    /**\r\n     * Retrieves the top operation in the stack without removing it.\r\n     * @returns The top operation or undefined if the stack is empty.\r\n     */\r\n    peek(): Instruction | undefined {\r\n      return stack$.value[stack$.value.length - 1];\r\n    },\r\n\r\n    /**\r\n     * Removes the specified operation from the stack.\r\n     * @param item The operation to remove.\r\n     * @returns The removed operation or undefined if the operation was not found.\r\n     */\r\n    remove(item: Instruction): Instruction | undefined {\r\n      const index = stack$.value.lastIndexOf(item);\r\n      if (index > -1) {\r\n        const newStack = stack$.value.filter((_, i) => i !== index);\r\n        stack$.next(newStack);\r\n        return item;\r\n      }\r\n      return undefined;\r\n    },\r\n\r\n    /**\r\n     * Clears all operations from the stack.\r\n     */\r\n    clear(): void {\r\n      stack$.next([]);\r\n    },\r\n\r\n    /**\r\n     * Converts the stack to an array of instructions.\r\n     * @returns An array of instructions.\r\n     */\r\n    toArray(): Instruction[] {\r\n      return [...stack$.value];\r\n    },\r\n\r\n    /**\r\n     * Finds the last operation in the stack that satisfies a given condition.\r\n     * @param condition The condition to match the operation.\r\n     * @returns The last matching operation or undefined if no match is found.\r\n     */\r\n    findLast(condition: (element: Instruction) => boolean): Instruction | undefined {\r\n      return stack$.value.slice().reverse().find(condition);\r\n    },\r\n\r\n    /**\r\n     * Waits for the stack to become empty.\r\n     * @returns A promise that resolves when the stack is empty.\r\n     */\r\n    waitForEmpty(): Promise<Instruction[]> {\r\n      return waitFor(stack$, stack => stack.length === 0);\r\n    },\r\n\r\n    /**\r\n     * Waits for the stack to become idle (i.e., no \"action\" operations are in progress).\r\n     * @returns A promise that resolves when the stack becomes idle.\r\n     */\r\n    waitForIdle(): Promise<Instruction[]> {\r\n      return waitFor(stack$, stack => !stack.some(item => item.type === \"action\"));\r\n    },\r\n\r\n    /**\r\n     * Exposes the underlying observable stream for external subscription.\r\n     */\r\n    get observable(): Observable<Instruction[]> {\r\n      return stack$.asObservable();\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * Waits for a condition to be met in an observable stream.\r\n * @template T\r\n * @param obs The observable stream to observe.\r\n * @param predicate A predicate function to evaluate each emitted value.\r\n * @returns A promise that resolves when the condition is met.\r\n */\r\nfunction waitFor<T>(obs: Observable<T>, predicate: (value: T) => boolean): Promise<T> {\r\n  return new Promise<T>((resolve, reject) => {\r\n    const subscription = obs.subscribe({\r\n      next: value => {\r\n        if (predicate(value)) {\r\n          subscription.unsubscribe();\r\n          resolve(value);\r\n        }\r\n      },\r\n      error: reject,\r\n      complete: () => reject(\"Observable completed before condition was met\"),\r\n    });\r\n  });\r\n}\r\n","import { createLock, SimpleLock } from './lock';\r\nimport { createInstruction, createExecutionStack, Instruction, ExecutionStack } from './stack';\r\nimport { Action, AsyncAction } from './types';\r\n\r\n/**\r\n * Configuration object for the middleware.\r\n *\r\n * @typedef {Object} MiddlewareConfig\r\n * @property {Function} dispatch - Function to dispatch actions.\r\n * @property {Function} getState - Function to get the current state.\r\n * @property {Function} dependencies - Function to get dependencies.\r\n * @property {SimpleLock} lock - Lock instance to manage action processing concurrency.\r\n * @property {ExecutionStack} stack - Stack instance to track action execution.\r\n */\r\ninterface MiddlewareConfig {\r\n  dispatch: Function;\r\n  getState: Function;\r\n  dependencies: Function;\r\n  lock: SimpleLock;\r\n  stack: ExecutionStack;\r\n}\r\n\r\n/**\r\n * Functional handler for managing actions within middleware.\r\n *\r\n * @param {MiddlewareConfig} config - Configuration object for the middleware.\r\n * @returns {Function} - A function to handle actions.\r\n */\r\nexport function createActionHandler(config: MiddlewareConfig) {\r\n  const stack = config.stack;\r\n  const getState = config.getState;\r\n  const dependencies = config.dependencies;\r\n\r\n  /**\r\n   * Handles the given action, processing it either synchronously or asynchronously.\r\n   *\r\n   * @param {Action | AsyncAction} action - The action to be processed.\r\n   * @param {Function} next - The next middleware function in the chain.\r\n   * @param {SimpleLock} lock - The lock instance to manage concurrency for this action.\r\n   * @returns {Promise<void> | void} - A promise if the action is asynchronous, otherwise void.\r\n   */\r\n  const handleAction = async (action: Action | AsyncAction, next: Function, lock: SimpleLock): Promise<void> => {\r\n    await lock.acquire();\r\n\r\n    const op = createInstruction.action(action);\r\n    stack.add(op);\r\n\r\n    try {\r\n      if (typeof action === 'function') {\r\n        const innerLock = createLock();\r\n\r\n        // Process async actions asynchronously and track them\r\n        await action(\r\n          async (syncAction: Action) => {\r\n            await handleAction(syncAction, next, innerLock);\r\n          },\r\n          getState,\r\n          dependencies()\r\n        );\r\n      } else {\r\n        // Process regular synchronous actions\r\n        await next(action);\r\n      }\r\n    } finally {\r\n      stack.remove(op);\r\n      lock.release();\r\n    }\r\n  };\r\n\r\n  return handleAction;\r\n}\r\n\r\n/**\r\n * Function to create the starter middleware factory.\r\n * This factory function returns a middleware creator that takes strategy information as arguments and returns the actual middleware function.\r\n *\r\n * @returns Function - The middleware creator function.\r\n */\r\nexport const createStarter = () => {\r\n  /**\r\n   * Middleware function for handling actions exclusively.\r\n   *\r\n   * This middleware ensures only one action is processed at a time and queues new actions until the current one finishes.\r\n   *\r\n   * @param args - Arguments provided by the middleware pipeline.\r\n   *   * dispatch - Function to dispatch actions.\r\n   *   * getState - Function to get the current state.\r\n   *   * dependencies - Function to get dependencies.\r\n   * @param next - Function to call the next middleware in the chain.\r\n   * @returns Function - The actual middleware function that handles actions.\r\n   */\r\n  const exclusive = (config: MiddlewareConfig) => (next: Function) => async (action: Action | AsyncAction) => {\r\n    const handler = createActionHandler(config);\r\n    const lockInstance = config.lock;\r\n    await handler(action, next, lockInstance);\r\n  };\r\n\r\n  /**\r\n   * Middleware function for handling actions concurrently.\r\n   *\r\n   * This middleware allows multiple async actions to be processed simultaneously.\r\n   *\r\n   * @param args - Arguments provided by the middleware pipeline (same as exclusive).\r\n   * @param next - Function to call the next middleware in the chain.\r\n   * @returns Function - The actual middleware function that handles actions.\r\n   */\r\n  const concurrent = (config: MiddlewareConfig) => (next: Function) => async (action: Action | AsyncAction) => {\r\n    let asyncActions: Promise<void>[] = [];\r\n    const handler = createActionHandler(config);\r\n    const lockInstance = config.lock;\r\n\r\n    const asyncFunc = handler(action, next, lockInstance);\r\n    if (asyncFunc) {\r\n      asyncActions.push(asyncFunc);\r\n      asyncFunc.finally(() => {\r\n        asyncActions = asyncActions.filter(func => func !== asyncFunc);\r\n      });\r\n    }\r\n  };\r\n\r\n  // Map strategy names to functions\r\n  const strategies: Record<string, any> = {\r\n    'exclusive': exclusive,\r\n    'concurrent': concurrent\r\n  };\r\n\r\n  const defaultStrategy = 'concurrent';\r\n\r\n  // Create a method to select the strategy\r\n  const selectStrategy = ({ dispatch, getState, dependencies, strategy, lock, stack }: any) => (next: Function) => async (action: Action) => {\r\n    let strategyFunc = strategies[strategy()];\r\n    if (!strategyFunc) {\r\n      console.warn(`Unknown strategy: ${strategy}, default is used: ${defaultStrategy}`);\r\n      strategyFunc = strategies[defaultStrategy];\r\n    }\r\n    return strategyFunc({ dispatch, getState, dependencies, lock, stack })(next)(action);\r\n  };\r\n\r\n  selectStrategy.signature = 'i.p.5.j.7.0.2.1.8.b';\r\n  return selectStrategy;\r\n};\r\n\r\n// Create the starter middleware\r\nexport const starter = createStarter();\r\n","import { Action, AsyncReducer, Reducer, StoreCreator, StoreEnhancer, Tree } from \"./types\";\r\n\r\n\r\n/**\r\n   * Updates a nested state object by applying a change to the specified path and value.\r\n   * Ensures that intermediate nodes in the state are properly cloned or created, preserving immutability\r\n   * for unchanged branches. Tracks visited nodes in the provided object tree to avoid redundant updates.\r\n   */\r\nfunction applyChange(initialState: any, {path, value}: {path: string[], value: any}, objTree: Tree<boolean>): any {\r\n  let currentState: any = Object.keys(objTree).length > 0 ? initialState: {...initialState};\r\n  let currentObj: any = currentState;\r\n\r\n  for (let i = 0; i < path.length; i++) {\r\n    const key = path[i];\r\n    if (i === path.length - 1) {\r\n      // Reached the leaf node, update its value\r\n      currentObj[key] = value;\r\n      objTree[key] = true;\r\n    } else {\r\n      // Continue traversal\r\n      currentObj = currentObj[key] = objTree[key] ? currentObj[key] : { ...currentObj[key] };\r\n      objTree = (objTree[key] = objTree[key] ?? {}) as any;\r\n    }\r\n  }\r\n  return currentState;\r\n}\r\n\r\n/**\r\n * Combines multiple store enhancers into a single enhancer function.\r\n * This allows multiple enhancers to be applied in sequence to the store.\r\n * Typically used for combining middleware, logging, or other store customizations.\r\n *\r\n * @param enhancers - An array of store enhancers to be combined.\r\n * @returns A single store enhancer that applies all provided enhancers.\r\n */\r\nfunction combineEnhancers(...enhancers: StoreEnhancer[]): StoreEnhancer {\r\n  // Collect the names of the enhancers for later access\r\n  const methodNames = enhancers.map(enhancer => enhancer.name);\r\n\r\n  // Create a new combined enhancer that wraps the enhancers\r\n  const combinedEnhancer = (next: StoreCreator) => {\r\n    // Apply each enhancer in the chain\r\n    return enhancers.reduceRight(\r\n      (acc, enhancer) => enhancer(acc),\r\n      next\r\n    );\r\n  };\r\n\r\n  // Attach the names of the enhancers to the combined enhancer\r\n  combinedEnhancer.names = methodNames;\r\n\r\n  return combinedEnhancer;\r\n}\r\n\r\n/**\r\n * Combines reducers into a single reducer function.\r\n * Initializes the default state by invoking each reducer with `undefined` and a special `@@INIT` action.\r\n */\r\nconst combineReducers = (reducers: Tree<Reducer | AsyncReducer>): AsyncReducer => {\r\n  /**\r\n   * Helper to validate reducers and flatten them into a single map.\r\n   *\r\n   * This recursively flattens the nested reducer tree and ensures all reducer paths are captured in the map.\r\n   */\r\n  const flattenReducers = (tree: Tree<Reducer | AsyncReducer>, path: string[] = []): Map<string, { reducer: AsyncReducer; path: string[] }> => {\r\n    const reducerMap = new Map<string, { reducer: AsyncReducer; path: string[] }>();\r\n\r\n    for (const key in tree) {\r\n      const reducer = tree[key];\r\n      const currentPath = [...path, key];\r\n\r\n      if (typeof reducer === \"function\") {\r\n        reducerMap.set(currentPath.join(\".\"), { reducer, path: currentPath });\r\n      } else if (typeof reducer === \"object\" && reducer !== null) {\r\n        // Recursively flatten the nested reducers.\r\n        const childReducers = flattenReducers(reducer, currentPath);\r\n        childReducers.forEach((childReducer, childKey) => {\r\n          reducerMap.set(childKey, childReducer);\r\n        });\r\n      } else {\r\n        throw new Error(`Invalid reducer at path: ${currentPath.join(\".\")}`);\r\n      }\r\n    }\r\n\r\n    return reducerMap;\r\n  };\r\n\r\n  const reducerMap = flattenReducers(reducers);\r\n\r\n  /**\r\n   * Helper to build the initial state by calling reducers with undefined state and a special `@@INIT` action.\r\n   *\r\n   * It gathers the initial state for each reducer, ensuring the nested structure is respected.\r\n   */\r\n  const gatherInitialState = async (): Promise<any> => {\r\n    const initialState: any = {};\r\n\r\n    for (const { reducer, path } of reducerMap.values()) {\r\n      const key = path[path.length - 1]; // Get the last key in the path as the state slice\r\n      try {\r\n        const initState = await reducer(undefined, { type: \"@@INIT\" } as Action);\r\n        let cursor = initialState;\r\n        for (let i = 0; i < path.length - 1; i++) {\r\n          cursor[path[i]] = cursor[path[i]] || {};\r\n          cursor = cursor[path[i]];\r\n        }\r\n        cursor[key] = initState;\r\n      } catch (error: any) {\r\n        console.error(`Error initializing state at path \"${path.join('.')}\" with action \"@@INIT\": ${error.message}`);\r\n      }\r\n    }\r\n\r\n    return initialState;\r\n  };\r\n\r\n  /**\r\n   * Combined reducer function.\r\n   *\r\n   * It processes each reducer asynchronously and ensures the state is only updated if necessary.\r\n   */\r\n  return async (state: any, action: Action): Promise<any> => {\r\n    if (state === undefined) {\r\n      state = await gatherInitialState();\r\n    }\r\n\r\n    let hasChanged = false;\r\n    const modified: any = {}; // To track the modifications\r\n    const nextState = { ...state };\r\n\r\n    // Process each reducer in the flattened reducer map\r\n    for (const { reducer, path } of reducerMap.values()) {\r\n      const key = path[path.length - 1];\r\n      const currentState = path.reduce((acc, key) => acc[key], state);\r\n\r\n      try {\r\n        const updatedState = await reducer(currentState, action);\r\n        if (currentState !== updatedState) {\r\n          hasChanged = true;\r\n          // Apply the change to the state using applyChange\r\n          state = await applyChange(state, { path, value: updatedState }, modified);\r\n        }\r\n      } catch (error: any) {\r\n        console.error(\r\n          `Error processing reducer at \"${path.join(\".\")}\" with action \"${action.type}\": ${error.message}`\r\n        );\r\n      }\r\n    }\r\n\r\n    // Return the state only if it has changed, otherwise return the previous state.\r\n    return hasChanged ? state : nextState;\r\n  };\r\n};\r\n\r\n/**\r\n * Applies middleware to the store's dispatch function.\r\n * Middleware enhances the dispatch function, allowing actions to be intercepted and modified.\r\n *\r\n * @param {...Function[]} middlewares Middleware functions to apply.\r\n * @returns A store enhancer that applies the middleware to the store.\r\n */\r\nconst applyMiddleware = (...middlewares: Function[]): StoreEnhancer => {\r\n  const enhancer: StoreEnhancer = (next) => (mainModule, settings, enhancer) => {\r\n    // Create the store with the original reducer and enhancer\r\n    const store = next(mainModule, settings, enhancer);\r\n\r\n    // Define starter and middleware APIs\r\n    const middlewareAPI = store.getMiddlewareAPI();\r\n\r\n    // Build middleware chain\r\n    const chain = [store.starter(middlewareAPI), ...middlewares.map(middleware => middleware(middlewareAPI))] as any[];\r\n\r\n    // Compose the middleware chain into a single dispatch function\r\n    let dispatch = chain.reduceRight(\r\n      (next, middleware) => middleware(next),\r\n      store.dispatch\r\n    );\r\n\r\n    // Return the enhanced store\r\n    return {\r\n      ...store,\r\n      dispatch, // Overwrite dispatch with the enhanced dispatch\r\n    };\r\n  };\r\n\r\n  // Ensure the 'name' property is properly set for the enhancer\r\n  Object.defineProperty(enhancer, 'name', { value: 'applyMiddleware' });\r\n  return enhancer;\r\n};\r\n\r\nexport {\r\n  applyChange,\r\n  applyMiddleware,\r\n  combineEnhancers,\r\n  combineReducers,\r\n}\r\n","import { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';\r\nimport { Observable } from 'rxjs/internal/Observable';\r\n\r\n/**\r\n * A utility type for tracking the execution status of Observables.\r\n */\r\nexport type Tracker = {\r\n  /**\r\n   * Execution timeout in milliseconds.\r\n   */\r\n  timeout: number;\r\n\r\n  /**\r\n   * Gets the execution status of a tracked Observable.\r\n   *\r\n   * @param {Observable<any>} entry - The Observable to check the status for.\r\n   * @returns {boolean} - `true` if the Observable is executing, `false` otherwise.\r\n   */\r\n  getStatus: (entry: Observable<any>) => boolean;\r\n\r\n  /**\r\n   * Sets the execution status of a tracked Observable.\r\n   *\r\n   * @param {Observable<any>} entry - The Observable to update the status for.\r\n   * @param {boolean} value - The new execution status.\r\n   */\r\n  setStatus: (entry: Observable<any>, value: boolean) => void;\r\n\r\n  /**\r\n   * Marks a tracked Observable as completed.\r\n   *\r\n   * @param {Observable<any>} entry - The Observable to mark as completed.\r\n   */\r\n  complete: (entry: Observable<any>) => void;\r\n\r\n  /**\r\n   * Tracks a new Observable.\r\n   *\r\n   * @param {Observable<any>} observable - The Observable to start tracking.\r\n   */\r\n  track: (observable: Observable<any>) => void;\r\n\r\n  /**\r\n   * Removes a tracked Observable and unsubscribes its BehaviorSubject.\r\n   *\r\n   * @param {Observable<any>} observable - The Observable to stop tracking.\r\n   */\r\n  remove: (observable: Observable<any>) => void;\r\n\r\n  /**\r\n   * Resets the execution status of all tracked Observables to `false`.\r\n   */\r\n  reset: () => void;\r\n\r\n  /**\r\n   * Asynchronously checks if all tracked Observables have completed within a timeout period.\r\n   *\r\n   * @returns {Promise<void>} - Resolves if all Observables complete within the timeout, rejects otherwise.\r\n   */\r\n  allExecuted: () => Promise<void>;\r\n};\r\n\r\n/**\r\n * Creates a new functional Tracker for managing the execution status of Observables.\r\n *\r\n * @returns {Tracker} - A Tracker instance.\r\n */\r\nexport const createTracker = (): Tracker => {\r\n  const entries = new Map<Observable<any>, BehaviorSubject<boolean>>();\r\n  const timeout = 30000;\r\n\r\n  /**\r\n   * Gets the execution status of a tracked Observable.\r\n   */\r\n  const getStatus: Tracker['getStatus'] = (entry) =>\r\n    entries.get(entry)?.value === true;\r\n\r\n  /**\r\n   * Sets the execution status of a tracked Observable.\r\n   */\r\n  const setStatus: Tracker['setStatus'] = (entry, value) =>\r\n    entries.get(entry)?.next(value);\r\n\r\n  /**\r\n   * Marks a tracked Observable as completed.\r\n   */\r\n  const setCompletion: Tracker['complete'] = (entry) =>\r\n    entries.get(entry)?.complete();\r\n\r\n  /**\r\n   * Tracks a new Observable.\r\n   */\r\n  const track: Tracker['track'] = (observable) => {\r\n    if (!entries.has(observable)) {\r\n      const subject = new BehaviorSubject<boolean>(false);\r\n      entries.set(observable, subject);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Removes a tracked Observable and unsubscribes its BehaviorSubject.\r\n   */\r\n  const remove: Tracker['remove'] = (observable) => {\r\n    const subject = entries.get(observable);\r\n    if (subject) {\r\n      entries.delete(observable);\r\n      subject.complete();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Resets the execution status of all tracked Observables to `false`.\r\n   */\r\n  const reset: Tracker['reset'] = () => {\r\n    for (const [key, value] of [...entries.entries()]) {\r\n      if (value.closed) {\r\n        entries.delete(key);\r\n      } else {\r\n        value.next(false);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Asynchronously checks if all tracked Observables have completed within a timeout period.\r\n   */\r\n  const allExecuted: Tracker['allExecuted'] = () =>\r\n    new Promise<void>((resolve, reject) => {\r\n      if ([...entries.values()].length === 0) {\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      const timeoutId = setTimeout(() => reject('Timeout reached'), timeout);\r\n      let numPending = [...entries.values()].length;\r\n\r\n      const handleCompletion = () => {\r\n        numPending--;\r\n        if (numPending === 0) {\r\n          clearTimeout(timeoutId);\r\n          resolve();\r\n        }\r\n      };\r\n\r\n      const handleError = (error: any) => {\r\n        clearTimeout(timeoutId);\r\n        reject(error);\r\n      };\r\n\r\n      [...entries.values()].forEach((subject) => {\r\n        subject.subscribe({\r\n          next: handleCompletion,\r\n          error: handleError,\r\n          complete: handleCompletion,\r\n        });\r\n      });\r\n    });\r\n\r\n  return {\r\n    timeout,\r\n    getStatus,\r\n    setStatus,\r\n    complete: setCompletion,\r\n    track,\r\n    remove,\r\n    reset,\r\n    allExecuted,\r\n  };\r\n};\r\n","import { inject } from '@angular/core';\r\nimport { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';\r\nimport { Observable } from 'rxjs/internal/Observable';\r\nimport { Subject } from 'rxjs/internal/Subject';\r\n\r\nimport { action, bindActionCreators } from './actions';\r\nimport { applyChange, applyMiddleware, combineEnhancers, combineReducers } from './utils';\r\nimport { createLock } from './lock';\r\nimport { createExecutionStack } from './stack';\r\nimport { starter } from './starter';\r\nimport { createTracker, Tracker } from './tracker';\r\nimport {\r\n  Action,\r\n  AnyFn,\r\n  AsyncReducer,\r\n  defaultMainModule,\r\n  FeatureModule,\r\n  isPlainObject,\r\n  kindOf,\r\n  MainModule,\r\n  MetaReducer,\r\n  Middleware,\r\n  MiddlewareAPI,\r\n  Observer,\r\n  ProcessingStrategy,\r\n  Reducer,\r\n  StoreEnhancer,\r\n  Tree,\r\n} from './types';\r\n\r\n\r\n/**\r\n * Class representing configuration options for a store.\r\n * This class defines properties that control various behaviors of a store for managing application state.\r\n */\r\nexport type StoreSettings = {\r\n  dispatchSystemActions?: boolean;\r\n  awaitStatePropagation?: boolean;\r\n  enableMetaReducers?: boolean;\r\n  enableAsyncReducers?: boolean;\r\n  exclusiveActionProcessing?: boolean;\r\n};\r\n\r\n/**\r\n * The default settings for the store that configure various behaviors such as action dispatch,\r\n * state propagation, and reducer handling.\r\n */\r\nconst defaultStoreSettings: StoreSettings = {\r\n  dispatchSystemActions: true,\r\n  awaitStatePropagation: true,\r\n  enableMetaReducers: true,\r\n  enableAsyncReducers: true,\r\n  exclusiveActionProcessing: false\r\n};\r\n\r\n/**\r\n * The `Store` type represents the core store object that manages state, actions, and modules.\r\n * It provides methods to interact with the store's state, dispatch actions, load/unload modules, and more.\r\n */\r\nexport type Store<T = any> = {\r\n  dispatch: (action: Action | any) => Promise<void>;\r\n  getState: (slice?: keyof T | string[] | \"@global\") => any;\r\n  readSafe: (slice: keyof T | string[] | \"@global\", callback: (state: Readonly<T>) => void | Promise<void>) => Promise<void>;\r\n  select: <R = any>(selector: (obs: Observable<T>, tracker?: Tracker) => Observable<R>, defaultValue?: any) => Observable<R>;\r\n  loadModule: (module: FeatureModule) => Promise<void>;\r\n  unloadModule: (module: FeatureModule, clearState: boolean) => Promise<void>;\r\n  getMiddlewareAPI: () => any;\r\n  starter: Middleware;\r\n};\r\n\r\n/**\r\n * Constant array containing system action types as strings.\r\n * These action types are likely used internally for system events.\r\n */\r\nconst SYSTEM_ACTION_TYPES = [\r\n  \"INITIALIZE_STATE\",\r\n  \"UPDATE_STATE\",\r\n  \"STORE_INITIALIZED\",\r\n  \"MODULE_LOADED\",\r\n  \"MODULE_UNLOADED\"\r\n] as const;\r\n\r\n/**\r\n * Type alias representing all possible system action types.\r\n * This type is derived from the `SYSTEM_ACTION_TYPES` array using the `typeof` operator and ensures the type is also a string.\r\n */\r\nexport type SystemActionTypes = typeof SYSTEM_ACTION_TYPES[number] & string;\r\n\r\n/**\r\n * Function to check if a given string is a system action type.\r\n */\r\nexport function isSystemActionType(type: string): type is SystemActionTypes {\r\n  return SYSTEM_ACTION_TYPES.includes(type as SystemActionTypes);\r\n}\r\n\r\n/**\r\n * Private function to create a system action.\r\n */\r\nfunction systemAction<T extends SystemActionTypes>(type: T, payload?: Function) {\r\n  return action(type, payload);\r\n}\r\n\r\n/**\r\n * Object containing action creator functions for all system action types.\r\n * Each property name corresponds to a system action type, and the function creates an action object with that type and optional payload.\r\n */\r\nconst systemActions = {\r\n  initializeState: systemAction(\"INITIALIZE_STATE\"),\r\n  updateState: systemAction(\"UPDATE_STATE\"),\r\n  storeInitialized: systemAction(\"STORE_INITIALIZED\"),\r\n  moduleLoaded: systemAction(\"MODULE_LOADED\", (module: FeatureModule) => ({module})),\r\n  moduleUnloaded: systemAction(\"MODULE_UNLOADED\", (module: FeatureModule) => ({module}))\r\n};\r\n\r\n/**\r\n * Creates a new store instance.\r\n *\r\n * This function initializes a store with the provided `mainModule` configuration and optional store enhancer.\r\n * It also accepts store settings that define various configuration options for the store.\r\n * The `storeSettings` parameter defaults to `defaultStoreSettings` if not provided.\r\n */\r\nexport function createStore<T = any>(\r\n  mainModule: MainModule,\r\n  storeSettingsOrEnhancer?: StoreSettings | StoreEnhancer,\r\n  enhancer?: StoreEnhancer\r\n): Store<T> {\r\n  let main = { ...defaultMainModule, ...mainModule };\r\n  let modules: FeatureModule[] = [];\r\n\r\n  let sysActions = { ...systemActions };\r\n\r\n  // Determine if the second argument is storeSettings or enhancer\r\n  let settings: StoreSettings;\r\n  if (typeof storeSettingsOrEnhancer === \"function\") {\r\n    // If it's a function, it's the enhancer\r\n    enhancer = storeSettingsOrEnhancer;\r\n    settings = defaultStoreSettings; // Use default settings if not provided\r\n  } else {\r\n    // Otherwise, it's storeSettings\r\n    settings = { ...storeSettingsOrEnhancer, ...defaultStoreSettings };\r\n  }\r\n\r\n  // Configure store pipeline\r\n  let pipeline = {\r\n    reducer: combineReducers({ [main.slice!]: main.reducer }),\r\n    dependencies: {},\r\n    strategy: settings.exclusiveActionProcessing ? \"exclusive\" : \"concurrent\"\r\n  };\r\n\r\n  const currentState = new BehaviorSubject<any>({});\r\n  const tracker = createTracker();\r\n  const lock = createLock();\r\n  const stack = createExecutionStack();\r\n\r\n  /**\r\n   * Dispatches an action to update the global state.\r\n   *\r\n   * The function validates the action to ensure it is a plain object with a defined and string type property.\r\n   * If any validation fails, a warning is logged to the console and the action is not dispatched.\r\n   * After validation, the action is processed by the reducer, and the global state is updated accordingly.\r\n   */\r\n  let dispatch = async (action: Action | any) => {\r\n    if (!isPlainObject(action)) {\r\n      console.warn(`Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'.`);\r\n      return;\r\n    }\r\n    if (typeof action.type === 'undefined') {\r\n      console.warn('Actions may not have an undefined \"type\" property.');\r\n      return;\r\n    }\r\n    if (typeof action.type !== 'string') {\r\n      console.warn(`Action \"type\" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'.`);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await updateState('@global', async (state: any) => await pipeline.reducer(state, action), action);\r\n    } catch {\r\n      console.warn('Error during processing the action');\r\n    }\r\n  };\r\n\r\n  /**\r\n * Recursively processes a nested structure of dependencies, handling arrays, objects, and class instances.\r\n *\r\n * @param {any} source The source object to process.\r\n * @param {Object} processed The object to accumulate processed values.\r\n * @param {string} origin The origin of the current source object (e.g., module name).\r\n * @returns {any} The processed object.\r\n *\r\n * @description\r\n * This function recursively traverses the `source` object, processing its properties and handling arrays, objects, and class instances. It merges overlapping properties from different sources, logging a warning for each conflict.\r\n *\r\n * - **Array Handling:** Recursively processes each element of an array.\r\n * - **Plain Object Handling:** Iterates over the properties of a plain object, recursively processing each value and merging them into the `processed` object. Logs a warning for overlapping properties.\r\n * - **Class Instance Handling:** Returns the original class instance without modification to avoid unintended side effects.\r\n *\r\n * @example\r\n * const dependencies = {\r\n *   a: { b: 1, c: [2, { d: 3 }] },\r\n *   e: new SomeClass(),\r\n * };\r\n *\r\n * const processedDependencies = processDependencies(dependencies);\r\n */\r\n  const processDependencies = (source: any, processed: any = {}, origin: string = ''): any => {\r\n    if (Array.isArray(source)) {\r\n      return source.map(item => processDependencies(item, processed));\r\n    }\r\n\r\n    if (source && typeof source === 'object') {\r\n      // Check if the source is a plain object\r\n      if (typeof source.constructor === 'function' && source.constructor !== Object) {\r\n        return source;\r\n      } else {\r\n        for (const [key, value] of Object.entries(source)) {\r\n          if (!processed.hasOwnProperty(key)) {\r\n            processed[key] = processDependencies(value, processed, origin);\r\n          } else {\r\n            console.warn(`Overlapping property '${key}' found in dependencies from module: ${origin}. The existing value will be preserved.`);\r\n          }\r\n        }\r\n        return processed;// Assume it's a class instance or other non-plain object\r\n      }\r\n    }\r\n\r\n    return source;\r\n  };\r\n\r\n  /**\r\n   * Merges and injects dependencies from the main module and all feature modules\r\n   * into the pipeline's dependency object. Handles class instantiation.\r\n   */\r\n  const injectDependencies = (): void => {\r\n    const allDependencies = [mainModule, ...modules].reduce((acc, module) => {\r\n      return processDependencies(module.dependencies, acc, module.slice);\r\n    }, {});\r\n\r\n    pipeline.dependencies = allDependencies;\r\n  };\r\n\r\n  /**\r\n   * Removes the specified module's dependencies from the pipeline and updates\r\n   * the global dependencies object, ensuring proper handling of nested structures.\r\n   */\r\n  const ejectDependencies = (module: FeatureModule): void => {\r\n    const otherModules = [mainModule, ...modules].filter(m => m !== module);\r\n    const remainingDependencies = otherModules.reduce((acc, module) => {\r\n      return processDependencies(module.dependencies, acc, module.slice);\r\n    }, {});\r\n\r\n    pipeline.dependencies = remainingDependencies;\r\n  };\r\n\r\n  /**\r\n   * Loads a new feature module into the store if it isn't already loaded.\r\n   * It ensures that dependencies are injected, the global state is updated,\r\n   * and a `moduleLoaded` action is dispatched once the module is successfully loaded.\r\n   */\r\n  const loadModule = (module: FeatureModule): Promise<void> => {\r\n    // Check if the module already exists\r\n    if (modules.some(m => m.slice === module.slice)) {\r\n      return Promise.resolve(); // Module already exists, return without changes\r\n    }\r\n\r\n    const promise = lock.acquire()\r\n      .then(() => {\r\n        // Create a new array with the module added\r\n        modules = [...modules, module];\r\n\r\n        // Inject dependencies\r\n        return injectDependencies();\r\n      })\r\n      .then(() => updateState(\"@global\", state => setupReducer(state)))\r\n      .finally(() => lock.release());\r\n\r\n    // Dispatch module loaded action\r\n    systemActions.moduleLoaded(module);\r\n    return promise;\r\n  }\r\n\r\n  /**\r\n   * Unloads a feature module from the store, optionally clearing its state.\r\n   * It removes the module, ejects its dependencies, and updates the global state.\r\n   * A `moduleUnloaded` action is dispatched after the module is unloaded.\r\n   */\r\n  const unloadModule = (module: FeatureModule, clearState: boolean = false): Promise<void> => {\r\n    // Find the module index in the modules array\r\n    const moduleIndex = modules.findIndex(m => m.slice === module.slice);\r\n\r\n    // Check if the module exists\r\n    if (moduleIndex === -1) {\r\n      console.warn(`Module ${module.slice} not found, cannot unload.`);\r\n      return Promise.resolve(); // Module not found, nothing to unload\r\n    }\r\n\r\n    const promise = lock.acquire()\r\n      .then(() => {\r\n        // Remove the module from the internal state\r\n        modules.splice(moduleIndex, 1);\r\n\r\n        // Eject dependencies\r\n        return ejectDependencies(module);\r\n      })\r\n      .then(() => updateState(\"@global\", async (state) => {\r\n        if (clearState) {\r\n          state = { ...state };\r\n          delete state[module.slice];\r\n        }\r\n        return await setupReducer(state);\r\n      }))\r\n      .finally(() => lock.release());\r\n\r\n    // Dispatch module unloaded action\r\n    systemActions.moduleUnloaded(module);\r\n    return promise;\r\n  }\r\n\r\n  /**\r\n   * Selects a specific value from the state using the provided selector function.\r\n   * The function returns an observable that emits the selected value whenever the state changes.\r\n   * Optionally, a default value can be provided if the selector returns `undefined`.\r\n   */\r\n  const getState = (slice?: keyof T | string[] | \"@global\"): any => {\r\n    if (currentState.value === undefined || slice === undefined || typeof slice === \"string\" && slice == \"@global\") {\r\n      return currentState.value as T;\r\n    } else if (typeof slice === \"string\") {\r\n      return currentState.value[slice] as T;\r\n    } else if (Array.isArray(slice)) {\r\n      return slice.reduce((acc, key) => {\r\n        if (acc === undefined || acc === null) {\r\n          return undefined;\r\n        } else if (Array.isArray(acc)) {\r\n          return acc[parseInt(key)];\r\n        } else {\r\n          return acc[key];\r\n        }\r\n      }, currentState.value) as T;\r\n    } else {\r\n      console.warn(\"Unsupported type of slice parameter\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the state for a specified slice of the global state, updating it with the given value.\r\n   * Handles different slice types, including a specific key, an array of path keys, or the entire global state.\r\n   */\r\n  const setState = async <T = any>(slice: keyof T | string[] | \"@global\" | undefined, value: any, action = systemActions.updateState() as Action): Promise<any> => {\r\n    let newState: any;\r\n    if (slice === undefined || typeof slice === \"string\" && slice == \"@global\") {\r\n      // Update the whole state with a shallow copy of the value\r\n      newState = ({...value});\r\n    } else if (typeof slice === \"string\") {\r\n      // Update the state property with the given key with a shallow copy of the value\r\n      newState = {...currentState.value, [slice]: { ...value }};\r\n    } else if (Array.isArray(slice)) {\r\n      // Apply change to the state based on the provided path and value\r\n      newState = applyChange(currentState.value, {path: slice, value}, {});\r\n    } else {\r\n      // Unsupported type of slice parameter\r\n      console.warn(\"Unsupported type of slice parameter\");\r\n      return;\r\n    }\r\n\r\n\r\n    currentState.next(newState);\r\n\r\n    if (settings.awaitStatePropagation) {\r\n      await tracker.allExecuted;\r\n      tracker.reset();\r\n    }\r\n\r\n    return newState;\r\n  }\r\n\r\n  /**\r\n   * Updates the state for a specified slice by executing the provided callback function,\r\n   * which receives the current state as its argument and returns the updated state.\r\n   * The resulting state is then set using the `setState` function.\r\n   */\r\n  const updateState = async (slice: keyof T | string[] | \"@global\" | undefined, callback: AnyFn, action = systemActions.updateState() as Action): Promise<any> => {\r\n    if(callback === undefined) {\r\n      console.warn('Callback function is missing. State will not be updated.')\r\n      return;\r\n    }\r\n\r\n    let state = getState(slice);\r\n    let result = await callback(state);\r\n    await setState(slice, result, action);\r\n\r\n    return action;\r\n  };\r\n\r\n  /**\r\n   * Reads the state slice and executes the provided callback with the current state.\r\n   * The function ensures that state is accessed in a thread-safe manner by acquiring a lock.\r\n   */\r\n  const readSafe = (slice: keyof T | string[], callback: (state:  Readonly<T>) => void | Promise<void>): Promise<void> => {\r\n    const promise = (async () => {\r\n      try {\r\n        await lock.acquire(); //Potentially we can check here for an idle of the pipeline\r\n        const state = await getState(slice); // Get state after acquiring lock\r\n        callback(state);\r\n      } finally {\r\n        lock.release(); // Release lock regardless of success or failure\r\n      }\r\n    })();\r\n\r\n    return promise;\r\n  }\r\n\r\n  /**\r\n   * Selects a value from the store's state using the provided selector function.\r\n   */\r\n  function select<T, R = any>(\r\n    selector: (obs: Observable<T>, tracker?: Tracker) => Observable<R>,\r\n    defaultValue?: R,\r\n    tracker?: Tracker,\r\n  ): Observable<R> {\r\n    const subject = new Subject<R>();\r\n    let selected$ = selector(currentState, tracker);\r\n    tracker?.track(selected$);\r\n\r\n    const subscription = selected$ // Create an inner subscription\r\n      .subscribe({\r\n        next: (value) => {\r\n          const filteredValue = value === undefined ? defaultValue : value;\r\n          if (filteredValue !== undefined) {\r\n            subject.next(filteredValue);\r\n            tracker?.setStatus(selected$, true);\r\n          }\r\n        },\r\n        error: (err) => {\r\n          subject.error(err)\r\n          tracker?.setStatus(selected$, true);\r\n        },\r\n        complete: () => {\r\n          tracker?.complete(selected$);\r\n          subject.complete();\r\n        }\r\n      });\r\n\r\n    if (subscription) { // Add inner subscription to the outer subscription\r\n      subscription.add(subscription);\r\n    }\r\n\r\n    return subject.asObservable();\r\n  }\r\n\r\n  /**\r\n   * Sets up and applies reducers for the feature modules, combining them into a single reducer function.\r\n   * Optionally applies meta reducers if enabled.\r\n   */\r\n  const setupReducer = async (state: any = {}): Promise<any> => {\r\n\r\n    let featureReducers = [{slice: mainModule.slice!, reducer: mainModule.reducer}, ...modules].reduce((reducers, module) => {\r\n      let moduleReducer: any = module.reducer instanceof Function ? module.reducer : {...module.reducer};\r\n      reducers = {...reducers, [module.slice]: moduleReducer};\r\n      return reducers;\r\n    }, {} as Tree<Reducer>);\r\n\r\n    let reducer = combineReducers(featureReducers);\r\n\r\n    // Define async compose function to apply meta reducers\r\n    const asyncCompose = (...fns: MetaReducer[]) => async (reducer: AsyncReducer) => {\r\n      for (let i = fns.length - 1; i >= 0; i--) {\r\n        try {\r\n          reducer = await fns[i](reducer);\r\n        } catch (error: any) {\r\n          console.warn(`Error in metareducer ${i}:`, error.message);\r\n        }\r\n      }\r\n      return reducer;\r\n    };\r\n\r\n    // Apply meta reducers if enabled\r\n    if (settings.enableMetaReducers && mainModule.metaReducers && mainModule.metaReducers.length) {\r\n      try {\r\n        reducer = await asyncCompose(...mainModule.metaReducers)(reducer);\r\n      } catch (error: any) {\r\n        console.warn('Error applying meta reducers:', error.message);\r\n      }\r\n    }\r\n\r\n    pipeline.reducer = reducer;\r\n\r\n    // Update store state\r\n    return await reducer(state, systemActions.updateState() as Action);\r\n  }\r\n\r\n  /**\r\n   * Creates the middleware API object for use in the middleware pipeline.\r\n   */\r\n  const getMiddlewareAPI = () => ({\r\n    getState: (slice?: any) => getState(slice),\r\n    dispatch: (action: any) => dispatch(action),\r\n    dependencies: () => pipeline.dependencies,\r\n    strategy: () => pipeline.strategy,\r\n    lock: lock,\r\n    stack: stack,\r\n  } as MiddlewareAPI);\r\n\r\n  // Apply enhancer if provided\r\n  if (typeof enhancer === \"function\") {\r\n    // Check if the enhancer contains applyMiddleware\r\n    const hasMiddlewareEnhancer = enhancer.name === 'applyMiddleware' || (enhancer as any).names?.includes('applyMiddleware');\r\n\r\n    // If no middleware enhancer is present, apply applyMiddleware explicitly with an empty array\r\n    if (!hasMiddlewareEnhancer) {\r\n      enhancer = combineEnhancers(enhancer, applyMiddleware());\r\n    }\r\n\r\n    return enhancer(createStore)(main, settings);\r\n  }\r\n\r\n  // Bind system actions\r\n  sysActions = bindActionCreators(systemActions, (action: Action) => settings.dispatchSystemActions && dispatch(action));\r\n\r\n  // Initialize state and mark store as initialized\r\n  sysActions.initializeState();\r\n\r\n  console.log(\"%cYou are using ActionStack. Happy coding! \", \"font-weight: bold;\");\r\n\r\n  lock.acquire()\r\n    .then(() => injectDependencies())\r\n    .then(() => setupReducer())\r\n    .then(state => setState(\"@global\", state))\r\n    .finally(() => lock.release());\r\n\r\n  sysActions.storeInitialized();\r\n\r\n  return {\r\n    starter,\r\n    dispatch,\r\n    getState,\r\n    readSafe,\r\n    select,\r\n    loadModule,\r\n    unloadModule,\r\n    getMiddlewareAPI,\r\n  } as Store<any>;\r\n}\r\n","/*\r\n * Public API Surface of actionstack\r\n */\r\n\r\nexport * from \"./lib\";\r\n\r\n\r\n\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["action"],"mappings":"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"}